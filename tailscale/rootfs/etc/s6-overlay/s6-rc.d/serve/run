#!/command/with-contenv bashio
# shellcheck shell=bash
# ==============================================================================
# Home Assistant Community Add-on: Tailscale
# Enables Tailscale Proxy and Funnel feature
# ==============================================================================

declare wait_counter=0
declare curl_result
declare tailscale_command

# Check if Tailscale HTTPS is enabled
if ! /opt/tailscale status --self=true --peers=false --json \
  | jq -rce '.Self.CapMap | has("https")' > /dev/null;
then
  bashio::log.error "Tailscale's HTTPS support is disabled"
  bashio::exit.nok
fi

# Checking if SSL is used
if bashio::var.true "$(bashio::core.ssl)"; then
  bashio::log.error "Tailscale's HTTPS support is enabled, but Home Assistant is not accessible through plain HTTP connection"
  bashio::exit.nok
fi

# Wait a bit for HA to be available during startup
while (( 200 != (curl_result=$(curl -s -o /dev/null -w "%{http_code}" "http://127.0.0.1:$(bashio::core.port)")) )); do
  if (( wait_counter++ == 18 )); then
    break
  fi
  bashio::log.info "Waiting for Home Assistant to be ready..."
  sleep 5
done
if (( wait_counter != 0 && curl_result == 200)); then
  bashio::log.info "Home Assistant is ready"
fi

if (( 200 != curl_result )); then
  # Warn that we can't test Home Assistant's HTTP reverse proxy configuration
  # We emit only a warning to let the add-on start, maybe this is the only connection to access the device, better to start than not
  # Though starting tailscale serve without HA won't fail, but will fill the logs with messages forever in each ~10s
  bashio::log.warning "Home Assistant is not accessible currently, unable to test the connection to Home Assistant as reverse proxy"
else
  # Test Home Assistant's HTTP reverse proxy configuration
  if (( 200 != $(curl -s -o /dev/null -w "%{http_code}" "http://127.0.0.1:$(bashio::core.port)" -H "X-Forwarded-For: 127.0.0.1") )); then
    bashio::log.error "Unable to connect to Home Assistant as reverse proxy"
    bashio::log.error "Please check your configuration based on the add-on's documentation under \"Option: proxy\""
    bashio::exit.nok
  fi
fi

if ! bashio::config.true 'funnel'; then
  tailscale_command=serve
else
  # Check if Funnel is available
  if ! /opt/tailscale status --self=true --peers=false --json \
    | jq -rce '.Self.CapMap | has("funnel")' > /dev/null;
  then
    bashio::log.error "Tailscale's Funnel support is disabled"
    bashio::exit.nok
  fi
  tailscale_command=funnel
fi

# ------------------------------------------------------------------------------
# Build tailscale serve/funnel command arguments:
# - Always map root "/" to local 127.0.0.1:8123 (Home Assistant default)
# - Use configured --https port (proxy_and_funnel_port) as before
# - Iterate /data/options.json services[] array and add each --set-path mapping
#   expected service formats:
#     - object: { "path": "/nodered", "port": 8443 }
#     - string: "8443:/nodered"
# ------------------------------------------------------------------------------

CONFIG_JSON='/data/options.json'
FUND_PORT="$(bashio::config "proxy_and_funnel_port" "443")"

# Build args array: first element is the subcommand (serve|funnel)
ARGS=( "${tailscale_command}" "--https=${FUND_PORT}" )

# Always serve HA default 8123 at root path "/"
# (user-requested behavior: default 8123 on root /)
ARGS+=( "--set-path=/" "http://127.0.0.1:8123" )
bashio::log.info "Added mapping: / -> 127.0.0.1:8123"

# If jq not present, warn and skip dynamic services. jq is commonly present in the add-on dev image,
# but if not, either add it to the Dockerfile (apk add --no-cache jq) or switch to another parsing method.
if ! command -v jq >/dev/null 2>&1; then
  bashio::log.warning "jq not found; skipping additional service mappings defined in services[]. To enable, include 'jq' in the add-on image."
else
  # If services key exists and is an array, iterate entries
  if jq -e '.services and ( .services | type == "array")' "${CONFIG_JSON}" >/dev/null 2>&1; then
    # iterate items without invoking subshell that would lose variable scope:
    # use read -r line in process substitution
    while IFS= read -r item; do
      # determine json type
      item_type=$(echo "${item}" | jq -r 'type' 2>/dev/null || echo "null")

      PORT_VAL=""
      PATH_VAL=""

      if [ "${item_type}" = "object" ]; then
        PORT_VAL=$(echo "${item}" | jq -r '.port // empty' 2>/dev/null)
        PATH_VAL=$(echo "${item}" | jq -r '.path // empty' 2>/dev/null)
      elif [ "${item_type}" = "string" ]; then
        # remove surrounding quotes if present (jq -c emits them for strings)
        pair=$(echo "${item}" | sed -e 's/^"//' -e 's/"$//')
        # expected format "port:/path" (port first)
        PORT_VAL=$(printf '%s' "${pair}" | cut -d: -f1)
        PATH_VAL=$(printf '%s' "${pair}" | cut -d: -f2-)
      else
        bashio::log.warning "Skipping unsupported service entry (not object/string): ${item}"
        continue
      fi

      # basic validation
      if [ -z "${PORT_VAL}" ] || [ -z "${PATH_VAL}" ]; then
        bashio::log.warning "Skipping service with missing port or path: ${item}"
        continue
      fi

      # normalize path (ensure leading slash)
      case "${PATH_VAL}" in
        /*) ;; # ok
        *) PATH_VAL="/${PATH_VAL}" ;;
      esac

      # add mapping argument(s) for tailscale
      ARGS+=( "--set-path=${PATH_VAL}" "http://127.0.0.1:${PORT_VAL}" )
      bashio::log.info "Added mapping: ${PATH_VAL} -> 127.0.0.1:${PORT_VAL}"

    done < <(jq -c '.services[]' "${CONFIG_JSON}")
  else
    bashio::log.info "No services array found in ${CONFIG_JSON}; only root mapping will be served."
  fi
fi

# Exec tailscale with the built arguments (replace current process)
# Example final invocation:
# /opt/tailscale serve --https=443 --set-path=/ http://127.0.0.1:8123 --set-path=/nodered http://127.0.0.1:8443 ...
bashio::log.info "Starting /opt/tailscale ${ARGS[*]}"
exec /opt/tailscale "${ARGS[@]}"
